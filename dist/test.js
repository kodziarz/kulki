/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./ts/Ball.ts":
/*!********************!*\
  !*** ./ts/Ball.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Ball)\n/* harmony export */ });\nclass Ball {\n    constructor() {\n    }\n}\nBall.YELLOW = 1;\n\n\n//# sourceURL=webpack://kulki-2/./ts/Ball.ts?");

/***/ }),

/***/ "./ts/Board.ts":
/*!*********************!*\
  !*** ./ts/Board.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Board)\n/* harmony export */ });\n/* harmony import */ var _Field__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Field */ \"./ts/Field.ts\");\n\nclass Board {\n    constructor(w, h) {\n        this.fields = [];\n        /**\n         * Checks if such a {@link Field~Field} exists on the {@link Board~Board}\n         * @param x X coordinate of {@link Field~Field}.\n         * @param y Y coordinate of {@link Field~Field}.\n         * @returns True if a {@link Field~Field} with such coordinates exists.\n         */\n        this.doesFieldExist = (x, y) => {\n            return !(this.fields[x] == null || this.fields[x] == undefined || this.fields[x][y] == null || this.fields[x][y] == undefined);\n        };\n        this.getHeight = () => {\n            return this.fields[0].length;\n        };\n        this.getWidth = () => {\n            return this.fields.length;\n        };\n        /**\n         * Returns a {@link Field~Field} by specific coordinates.\n         * @param x X coordinate of {@link Field~Field}.\n         * @param y Y coordinate of {@link Field~Field}.\n         * @returns {@link Field~Field} if it exists, otherwise null.\n         */\n        this.getField = (x, y) => {\n            if (!this.doesFieldExist(x, y))\n                return null;\n            return this.fields[x][y];\n        };\n        /**\n         * Returns a list of {@link Field~Field | Fields} which {@link Board~Board} contains.\n         * @returns Copy of two-dimensional array of {@link Field~Field | Fields}.\n         */\n        this.getFields = () => {\n            return [...this.fields].map((e) => { return [...e]; });\n        };\n        this.fields = [...new Array(w)].map((e, x) => { return [...new Array(h)].map((e, y) => { return new _Field__WEBPACK_IMPORTED_MODULE_0__[\"default\"](x, y); }); });\n    }\n}\n//można by zastosować DEKORATOR @notNull czy coś\n/**\n * Generates {@link Board~Board} instance from JSON data.\n * @param o JSON object which is going to be parsed.\n * @returns {@link Board~Board} object parsed from JSON data.\n */\nBoard.fromJSON = (o) => {\n    if (o == null || o == undefined)\n        throw new Error(\"Board cannot be parsed from null.\");\n    let result = Object.fromEntries(Object.entries(o).map(([key, value]) => {\n        if (key == \"fields\") {\n            return [key, [...value].map((column) => { return [...column].map((field) => { return Object.assign(new _Field__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 0), field); }); })];\n        }\n        else if (key == \"finish\") {\n            return [key, _Field__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromJSON(value)];\n        }\n        return [key, value];\n    }));\n    return Object.assign(new Board(0, 0), result);\n};\n\n\n//# sourceURL=webpack://kulki-2/./ts/Board.ts?");

/***/ }),

/***/ "./ts/Field.ts":
/*!*********************!*\
  !*** ./ts/Field.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Field)\n/* harmony export */ });\n/* harmony import */ var _Ball__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Ball */ \"./ts/Ball.ts\");\n\nclass Field {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    isLegal() {\n        return this._isLegal;\n    }\n    getX() {\n        return this.x;\n    }\n    getY() {\n        return this.y;\n    }\n}\n/**\n * Generates {@link Field~Field} instance from JSON data.\n * @param o JSON object which is going to be parsed.\n * @returns {@link Field~Field} object parsed from JSON data.\n */\nField.fromJSON = (o) => {\n    let result = Object.fromEntries(Object.entries(o).map(([key, value]) => {\n        if (key == \"ball\") {\n            return [key, Object.assign(new _Ball__WEBPACK_IMPORTED_MODULE_0__[\"default\"](), value)];\n        }\n        return [key, value];\n    }));\n    return Object.assign(new Field(result.x, result.y), result);\n};\n\n\n//# sourceURL=webpack://kulki-2/./ts/Field.ts?");

/***/ }),

/***/ "./ts/Main.ts":
/*!********************!*\
  !*** ./ts/Main.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Main)\n/* harmony export */ });\n/* harmony import */ var _Board__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Board */ \"./ts/Board.ts\");\n/* harmony import */ var _Field__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Field */ \"./ts/Field.ts\");\n/* harmony import */ var _Pathfinder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Pathfinder */ \"./ts/Pathfinder.ts\");\n/* harmony import */ var _UIManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./UIManager */ \"./ts/UIManager.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\nclass Main {\n    constructor() {\n        this.test = () => __awaiter(this, void 0, void 0, function* () {\n            let board = new _Board__WEBPACK_IMPORTED_MODULE_0__[\"default\"](9, 9);\n            //console.log(\"board: \", board);\n            let pathfinder = new _Pathfinder__WEBPACK_IMPORTED_MODULE_2__[\"default\"](board);\n            let path = pathfinder.findPath(new _Field__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0, 0), new _Field__WEBPACK_IMPORTED_MODULE_1__[\"default\"](8, 8));\n            console.log(\"path: \", path);\n            console.log(\"path: \", yield path);\n        });\n        this.root = document.getElementById(\"main\");\n        this.uiDiv = document.createElement(\"div\");\n        this.root.appendChild(this.uiDiv);\n        let board = new _Board__WEBPACK_IMPORTED_MODULE_0__[\"default\"](9, 9);\n        this.uiManager = new _UIManager__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.uiDiv);\n        this.uiManager.setGameboard(board);\n    }\n}\nwindow.onload = () => {\n    let main = new Main();\n};\n\n\n//# sourceURL=webpack://kulki-2/./ts/Main.ts?");

/***/ }),

/***/ "./ts/Path.ts":
/*!********************!*\
  !*** ./ts/Path.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Path)\n/* harmony export */ });\n/* harmony import */ var _Field__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Field */ \"./ts/Field.ts\");\n\n/**\n * Provides access to list of {@link Field~Field | Fields} in currently reaserched path to target.\n * Main aim is to manage permissions to data and actions performed on the object.\n * Used by {@link Walker~Walker} and {@link Pathfinder~Pathfinder}.\n */\nclass Path {\n    constructor() {\n        this.fields = [];\n        this.addField = (field) => {\n            this.fields.push(field);\n        };\n        this.getLastField = () => {\n            return this.fields[this.fields.length - 1];\n        };\n        this.getLength = () => {\n            return this.fields.length;\n        };\n    }\n}\n/**\n * Generates {@link Path~Path} instance from JSON data.\n * @param o JSON object which is going to be parsed.\n * @returns {@link Path~Path} object parsed from JSON data.\n */\nPath.fromJSON = (o) => {\n    let result = Object.fromEntries(Object.entries(o).map(([key, value]) => {\n        if (key == \"fields\") {\n            return [key, value.map((field) => {\n                    return _Field__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromJSON(field);\n                })];\n        }\n        return [key, value];\n    }));\n    return Object.assign(new Path(), result);\n};\n\n\n//# sourceURL=webpack://kulki-2/./ts/Path.ts?");

/***/ }),

/***/ "./ts/Pathfinder.ts":
/*!**************************!*\
  !*** ./ts/Pathfinder.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Pathfinder)\n/* harmony export */ });\n/* harmony import */ var _PathfinderMessage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PathfinderMessage */ \"./ts/PathfinderMessage.ts\");\n/* harmony import */ var _Walker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Walker */ \"./ts/Walker.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n/**\n * Finds shortest path with method {@link findPath}.\n */\nclass Pathfinder {\n    /**\n     * @param board Gameboard on which the shortest path is found.\n     */\n    constructor(board) {\n        /**@public List of workers currently working on finding shortest {@link Path~Path}. */\n        this.workers = [];\n        /**@public Map of currently shortest {@link Path~Path | Paths} to each {@link Field~Field} of given {@link Board~Board}. */\n        this.shortestPathsTo = [];\n        /**@public length of currently shortest {@link Path~Path} to {@link finish:member} */\n        this.shortestFinishedPathLength = null;\n        /**\n         * Finds the shortest {@link Path~Path} to finish {@link Field~Field}.\n         * @param start Beginning {@link Field~Field} of researched {@link Path~Path}.\n         * @param finish {@link Field~Field} where the {@link Path~Path} should lead to (target).\n         * @returns Promise with a {@link Path~Path}.\n         */\n        this.findPath = (start, finish) => __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                this.start = start;\n                this.finish = finish;\n                this.resolve = resolve;\n                if (this.gameBoard.doesFieldExist(start.getX(), start.getY())\n                    && this.gameBoard.doesFieldExist(finish.getX(), finish.getY())) {\n                    this.createNewWorker({\n                        type: _PathfinderMessage__WEBPACK_IMPORTED_MODULE_0__.PathfinderMessageTypes.PATHFIND,\n                        board: this.gameBoard,\n                        start: start,\n                        finish: finish\n                    });\n                }\n                else {\n                    reject(new Error(\"ChybaCiePowaliloException\"));\n                }\n            });\n        });\n        /**\n         * @public\n         * Creates new {@link worker} (new thread) and sets event handlers for him.\n         * @param message {@link PathfinderMessage~PathfinderMessage} which is going to be posted to {@link worker} just after creation of it.\n         */\n        this.createNewWorker = (message) => {\n            let worker = new Worker(Pathfinder.WORKER_FILE);\n            // whenever the worker reports reaching new Field it is checked, if there wasn't already a shorter path to it found.\n            worker.addEventListener(\"message\", (e) => {\n                let m = e.data;\n                switch (m.type) {\n                    case _PathfinderMessage__WEBPACK_IMPORTED_MODULE_0__.PathfinderMessageTypes.FIELD_REACHED:\n                        m.walker = _Walker__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromJSON(m.walker);\n                        // console.log(\"FIELD_REACHED\");\n                        // console.log(\"message: \", m);\n                        // debugger\n                        if (this.canWorkerBeFastest(m.walker)) {\n                            // found is better than current\n                            let lastField = m.walker.getPath().getLastField();\n                            this.shortestPathsTo[lastField.getX()][lastField.getY()] = m.walker.getPath();\n                            if (this.walkerDidReachedFinish(m.walker)) {\n                                this.removeWorker(worker);\n                                this.shortestFinishedPathLength = m.walker.getPath().getLength();\n                            }\n                            else\n                                worker.postMessage({ type: _PathfinderMessage__WEBPACK_IMPORTED_MODULE_0__.PathfinderMessageTypes.CONTINUE_PATHFINDING });\n                        }\n                        else {\n                            // found is already worse than current\n                            this.removeWorker(worker);\n                            // console.log(\"The worker was redundant. Current workers table length: \", this.workers.length);\n                        }\n                        // console.log(\"shortestPathsTo: \");\n                        // console.table(this.shortestPathsTo)\n                        // debugger\n                        break;\n                    case _PathfinderMessage__WEBPACK_IMPORTED_MODULE_0__.PathfinderMessageTypes.COWORKER_NEEDED:\n                        m.walker = _Walker__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromJSON(m.walker);\n                        if (this.canWorkerBeFastest(m.walker)) {\n                            let lastField = m.walker.getPath().getLastField();\n                            this.shortestPathsTo[lastField.getX()][lastField.getY()] = m.walker.getPath();\n                            if (this.walkerDidReachedFinish(m.walker)) {\n                                this.shortestFinishedPathLength = m.walker.getPath().getLength();\n                                console.log(\"Reached the end with path: \", m.walker.getPath());\n                            }\n                            else {\n                                this.createNewWorker({\n                                    type: _PathfinderMessage__WEBPACK_IMPORTED_MODULE_0__.PathfinderMessageTypes.CONTINUE_PATHFINDING_BY_DATA,\n                                    walker: m.walker\n                                });\n                            }\n                        }\n                        // console.log(\"shortestPathsTo: \");\n                        // console.table(this.shortestPathsTo)\n                        // debugger\n                        break;\n                    default:\n                        console.log(\"message: \", m);\n                        console.error(\"Unkown type of Pathfinder message.\");\n                }\n            });\n            worker.postMessage(JSON.parse(JSON.stringify(message)));\n            this.workers.push(worker);\n        };\n        /**\n         * @public Checks if the {@link Path~Path} of the given {@link Walker~Walker} is short enough that it is\n         * worth maintaining him.\n         * @param walker {@link Walker~Walker} whoose {@link Path~Path} is verified.\n         * @retuns True if the length of the {@link Walker~Walker | Walker's} {@link Path~Path} is shorter than\n         * currently shortest {@link Path~Path} to the {@link Field~Field} it leads to.\n         */\n        this.canWorkerBeFastest = (walker) => {\n            let checkedPath = walker.getPath();\n            if (this.shortestFinishedPathLength != null && checkedPath.getLength() < this.shortestFinishedPathLength)\n                return false;\n            let field = checkedPath.getLastField();\n            let currentPath = this.shortestPathsTo[field.getX()][field.getY()];\n            return currentPath == null || currentPath.getLength() > checkedPath.getLength();\n        };\n        /**\n         * Checks if specified {@link Walker~Walker} reached the {@link finish:member} {@link Field~Field}.\n         * @public\n         * @param walker {@link Walker~Walker} object from {@link worker}.\n         * @returns True, if {@link Walker~Walker} reached the {@link finish:member} {@link Field~Field}, otherwise false.\n         */\n        this.walkerDidReachedFinish = (walker) => {\n            return walker.getPath().getLastField().getX() == this.finish.getX()\n                && walker.getPath().getLastField().getY() == this.finish.getY();\n        };\n        /**\n         * Removes {@link worker} from table, terminates it and takes care of the fact, if the actual result is found.\n         * @public\n         * @param worker {@link worker} to remove.\n         * @remarks Invokes {@link finishPathfinding:function} method, if all {@link worker | workers} finished their work.\n         */\n        this.removeWorker = (worker) => {\n            this.workers.splice(this.workers.indexOf(worker), 1);\n            worker.terminate();\n            if (this.workers.length == 0)\n                this.finishPathfinding();\n        };\n        /**\n         * Executes {@link resolve:member} function.\n         * @public\n         */\n        this.finishPathfinding = () => {\n            this.resolve(this.shortestPathsTo[this.finish.getX()][this.finish.getY()]);\n        };\n        this.gameBoard = board;\n        this.shortestPathsTo = [...new Array(board.getWidth())].map(() => { return (new Array(board.getHeight())).fill(null); });\n        console.log(\"shortestPathsTo: \", this.shortestPathsTo);\n    }\n}\n/**Path to the {@link worker} script, which implements multitreading in the project. */\nPathfinder.WORKER_FILE = \"./dist/worker.js\";\n\n\n//# sourceURL=webpack://kulki-2/./ts/Pathfinder.ts?");

/***/ }),

/***/ "./ts/PathfinderMessage.ts":
/*!*********************************!*\
  !*** ./ts/PathfinderMessage.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PathfinderMessageTypes\": () => (/* binding */ PathfinderMessageTypes)\n/* harmony export */ });\n/**\n * Contains types of {@link PathfinderMessage}.\n */\nvar PathfinderMessageTypes;\n(function (PathfinderMessageTypes) {\n    /**\n     * {@link Pathfinder~Pathfinder} sends a request to {@link Walker~Walker} to start pathfinding.\n     * {@link PathfinderMessage~PathfinderMessage} with this type requires\n     * {@link PathfinderMessage~PathfinderMessage.start} and {@link PathfinderMessage~PathfinderMessage.finish}\n     */\n    PathfinderMessageTypes[PathfinderMessageTypes[\"PATHFIND\"] = 0] = \"PATHFIND\";\n    /**\n     * {@link Walker~Walker} emits an event, that he met a new {@link Field~Field}.\n     * {@link Pathfinder~Pathfinder} decides then, whether to maintain him or not.\n     */\n    PathfinderMessageTypes[PathfinderMessageTypes[\"FIELD_REACHED\"] = 1] = \"FIELD_REACHED\";\n    /**\n     * {@link Pathfinder~Pathfinder} sends request to {@link Walker~Walker} to continue pathfinding.\n     * Used after {@link Pathfinder~Pathfinder} gets {@link FIELD_REACHED} message and is interpreted by\n     * {@link Walker~Walker} as a permission to \"split\" (send {@link COWORKER_NEEDED} messages), if needed.\n     */\n    PathfinderMessageTypes[PathfinderMessageTypes[\"CONTINUE_PATHFINDING\"] = 2] = \"CONTINUE_PATHFINDING\";\n    /**\n     * {@link Walker~Walker} emits an event, that he needs to \"split\", to go in few directions.\n     * {@link Pathfinder~Pathfinder} receives then the new {@link Walker~Walker} object with a new\n     * {@link Field~Field} added to {@link Path~Path}\n     */\n    PathfinderMessageTypes[PathfinderMessageTypes[\"COWORKER_NEEDED\"] = 3] = \"COWORKER_NEEDED\";\n    /**\n     * {@link Pathfinder~Pathfinder} sens a request to {@link Walker~Walker} to continue pathfinding with some initial data.\n     * Used when {@link Pathfinder~Pathfinder} receives {@link COWORKER_NEEDED} message.\n     */\n    PathfinderMessageTypes[PathfinderMessageTypes[\"CONTINUE_PATHFINDING_BY_DATA\"] = 4] = \"CONTINUE_PATHFINDING_BY_DATA\";\n})(PathfinderMessageTypes || (PathfinderMessageTypes = {}));\n\n\n//# sourceURL=webpack://kulki-2/./ts/PathfinderMessage.ts?");

/***/ }),

/***/ "./ts/UIManager.ts":
/*!*************************!*\
  !*** ./ts/UIManager.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ UIManager)\n/* harmony export */ });\n/**\n * @module\n * Manages displaying data on the screen.\n */\nclass UIManager {\n    constructor(root) {\n        /**\n         * Sets the {@link Board~Board} which is going to be displayed anytime the\n         * {@link displayGameboard:function} method will be invoked.\n         * @param board {@link Board~Board} object.\n         */\n        this.setGameboard = (board) => {\n            this.gameboard = board;\n            this.divs = [...new Array(board.getWidth())].map((e, x) => { return [...new Array(board.getHeight())].map((e, y) => { return null; }); });\n            this.displayGameboard();\n        };\n        /**\n         * Displays gameboard basing on {@link gameboard:member} field, which can be set by\n         * {@link setGameboard:function} method.\n         */\n        this.displayGameboard = () => {\n            this.gameboard.getFields().forEach((column, x) => {\n                column.forEach((field, y) => {\n                    let div = document.createElement(\"div\");\n                    this.root.appendChild(div);\n                    this.divs[x][y] = div;\n                    div.style.position = \"absolute\";\n                    div.style.width = UIManager.CONSTS.DIV_SIZE + \"px\";\n                    div.style.height = UIManager.CONSTS.DIV_SIZE + \"px\";\n                    div.style.left = (x * UIManager.CONSTS.DIV_SIZE) + \"px\";\n                    div.style.top = (y * UIManager.CONSTS.DIV_SIZE) + \"px\";\n                    div.style.border = \"1px solid black\";\n                });\n            });\n        };\n        this.root = root;\n        this.root.style.position = \"relative\";\n    }\n}\nUIManager.CONSTS = {\n    DIV_SIZE: 50\n};\n\n\n//# sourceURL=webpack://kulki-2/./ts/UIManager.ts?");

/***/ }),

/***/ "./ts/Walker.ts":
/*!**********************!*\
  !*** ./ts/Walker.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Walker)\n/* harmony export */ });\n/* harmony import */ var _Board__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Board */ \"./ts/Board.ts\");\n/* harmony import */ var _Field__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Field */ \"./ts/Field.ts\");\n/* harmony import */ var _Path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Path */ \"./ts/Path.ts\");\n\n\n\nclass Walker {\n    constructor() {\n        /**\n         * Emited when Walker reaches new {@link Field~Field}. Used by {@link Pathfinder~Pathfinder} to decide, if the Walker should be maintained.\n         * @event\n         * @param walker {@link Walker~Walker}, who reached the {@link Field~Field}.\n         */\n        this.onFieldReached = (walker) => { };\n        /**\n         * Emited when {@link Walker~Walker} needs to \"split\" into few directions.\n         * @event\n         * @param walker New generated {@link Walker~Walker}\n         */\n        this.onCoworkerNeeded = (walker) => { };\n        /**\n         * Emited when {@link Walker~Walker} reaches the finish.\n         * @event\n         * @param walker {@link Walker~Walker} object which reached the finish.\n         */\n        this.onFinishReached = (walker) => { };\n        /**\n         * Method starts work of {@link Walker~Walker} to find {@link Path~Path}.\n         * @param start Start {@link Field~Field} for researched {@link Path~Path}.\n         * @param finish {@link Field~Field} where the {@link Path~Path} should lead to.\n         * @remarks Emits {@link onFieldReached:function} when reached new {@link Field~Field}.\n         */\n        this.findPath = (board, start, finish) => {\n            this.board = board;\n            this.path.addField(start);\n            this.finish = finish;\n            this.continuePathfinding();\n        };\n        /**\n         * Handles {@link PathfinderMessage~PathfinderMessageTypes.CONTINUE_PATHFINDING} message.\n         * Sends request to create new {@link worker | workers} and takes the first possible option (there is always\n         * at least one).\n         * @remarks Emits {@link onCoworkerNeeded:function} and {@link onFieldReached:function} events.\n         */\n        this.continuePathfinding = () => {\n            let possible = this.getPossibleDirectionsArray();\n            for (let i = 1; i < possible.length; i++) {\n                let coworker = this.duplicate();\n                coworker.getPath().addField(possible[i]);\n                this.onCoworkerNeeded(coworker);\n            }\n            this.path.addField(possible[0]);\n            this.onFieldReached(this);\n        };\n        /**\n         * Finds {@link Path~Path} starting with some initial data (method assumes that the {@link Walker~Walker}\n         * does not pathfind from the beginng of a {@link Path~Path}, because received {@link Walker~Walker} has some\n         * non-empty {@link Path~Path}).\n         * Used when {@link Walker~Walker} meets crossroads and needs to \"split\".\n         * @param walker Walker object containing initial data to pathfind.\n         * @remarks Emits {@link onFieldReached:function} event just after recieivng data ({@link Pathfinder~Pathfinder} needs\n         * to check, if his existence makes sense).\n         */\n        this.continuePathByData = (walker) => {\n            this.board = walker.board;\n            this.path = walker.getPath();\n            this.finish = walker.getFinish();\n            this.continuePathfinding();\n        };\n        /**@getter */\n        this.getPath = () => {\n            return this.path;\n        };\n        this.getFinish = () => {\n            return this.finish;\n        };\n        /**\n         * @public\n         * @returns List of {@link Field~Field | Fields} where the {@link Walker~Walker} can go.\n         * @remarks Used after receiving {@link PathfinderMessage~PathfinderMessageTypes.CONTINUE_PATHFINDING} message.\n         */\n        this.getPossibleDirectionsArray = () => {\n            let lastField = this.path.getLastField();\n            // console.log(\"this.path.getLastField(): \", this.path.getLastField());\n            let result = [];\n            if (this.board.doesFieldExist(lastField.getX() - 1, lastField.getY())) {\n                result.push(this.board.getField(lastField.getX() - 1, lastField.getY()));\n            }\n            if (this.board.doesFieldExist(lastField.getX(), lastField.getY() + 1)) {\n                result.push(this.board.getField(lastField.getX(), lastField.getY() + 1));\n            }\n            if (this.board.doesFieldExist(lastField.getX() + 1, lastField.getY())) {\n                result.push(this.board.getField(lastField.getX() + 1, lastField.getY()));\n            }\n            if (this.board.doesFieldExist(lastField.getX(), lastField.getY() - 1)) {\n                result.push(this.board.getField(lastField.getX(), lastField.getY() - 1));\n            }\n            return result;\n        };\n        /**\n         * Checks, if {@link Walker~Walker} has reached the target.\n         * @public\n         * @deprecated Everything which could be done be the function is performed by\n         * {@link Pathfinder~Pathfinder.walkerDidReachedFinish:function} inside {@link Pathfinder~Pathfinder}.\n         * @returns True if {@link Walker~Walker} has reached the {@link finish:member} {@link Field~Field},\n         * otherwise false.\n         */\n        this.isThisTheEnd = () => {\n            return this.path.getLastField().getX() == this.finish.getX()\n                && this.path.getLastField().getY() == this.finish.getY();\n        };\n        // toJSON = () => {\n        //     let result = Object.fromEntries(Object.entries(this).filter(([key, value]) => { return !(value instanceof Function) }))\n        //     result = Object.fromEntries(Object.entries(this).map(([key, value]) => {\n        //         if (value.toJSON != undefined)\n        //             return [key, value.toJSON()]\n        //         return [key, value]\n        //     }))\n        //     return result\n        // }\n        /**\n         * Creates a copy of the {@link Walker~Walker}.\n         * @returns Copied {@link Walker~Walker}.\n         * @remarks This should not be performed by a spread (\\{... \\}) operator, because then the child objects (e.g.\n         * {@link Path~Path}) would be copied by reference.\n         */\n        this.duplicate = () => {\n            return Walker.fromJSON(JSON.parse(JSON.stringify(this)));\n        };\n        this.path = new _Path__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n    }\n}\n/**\n * Generates {@link Walker~Walker} instance from JSON data.\n * @param o JSON object which is going to be parsed.\n * @returns {@link Walker~Walker} object parsed from JSON data.\n */\nWalker.fromJSON = (o) => {\n    let result = Object.fromEntries(Object.entries(o).map(([key, value]) => {\n        if (key == \"path\") {\n            return [key, _Path__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fromJSON(value)];\n        }\n        else if (key == \"finish\") {\n            return [key, _Field__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromJSON(value)];\n        }\n        else if (key == \"board\") {\n            return [key, _Board__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromJSON(value)];\n        }\n        return [key, value];\n    }));\n    return Object.assign(new Walker(), result);\n};\n\n\n//# sourceURL=webpack://kulki-2/./ts/Walker.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./ts/Main.ts");
/******/ 	
/******/ })()
;